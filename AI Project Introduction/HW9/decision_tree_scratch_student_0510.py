# -*- coding: utf-8 -*-
"""decision_tree_scratch_student_0510.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nsIusGUuVWBHzxuBdEP-D8GVJVisfrpf

### For student code
## STEP1. Make a toy dataset
"""

## Toy dataset
train_data = [
    ['Green', 3, 'Apple'],
    ['Yellow', 3, 'Apple'],
    ['Red', 1, 'Grape'],
    ['Red', 1, 'Grape'],
    ['Yellow', 3, 'Lemon'],
    ['Yellow', 4, 'Lemon']
]

columns = ['color', 'diameter', 'label']

"""---
## STEP2. Make useful functions 
"""


def unique_vals(rows, col):
    '''
  rows: list of row data
  col: the index of column that we want to find
  '''
    return set([row[col] for row in rows])


"""### Let's use _unique_vals_ function for finding the unique value!"""
unique_vals(train_data, 0)


def class_counts(rows):
    """Counts the number of each type of example in a dataset.
    rows: list of row data
    """
    counts = {}  # a dictionary of label -> count.

    for row in rows:
        # in our dataset format, the label is always the last column
        label = row[-1]

        if label not in counts:
            counts[label] = 0
        counts[label] += 1
    return counts


"""### Let's use _class_counts_ function!"""
class_counts(train_data)


def is_numeric(value):
    return isinstance(value, int) or isinstance(value, float)


"""### Let's use _is_numeric_ function!"""
print(is_numeric(7), is_numeric('Blue'))

"""---
## STEP3. Make a __Question__ class
- <font color='blue'>*Constructors* in python
  - Instantiating an object.  
  - Initialize to the data members of the class when an object of class is created
- <font color='blue'>*__ repr __ function* in python
  - Returns the object representation in string format.
"""


class Question:
    ## Constructor
    def __init__(self, column, value):
        self.column = column
        self.value = value

    def compare_with_question(self, example):
        '''
    Arguments:
    example -- List of row data (EX. ['Blue', 2, 'Blueberry'])
    '''
        val = example[self.column]

        if is_numeric(val):
            return val >= self.value
        else:
            return val == self.value

    ## Python __repr__() function returns the object representation in string format.
    def __repr__(self):
        condition = "=="

        if is_numeric(self.value):
            condition = ">="
        return "Is {} {} {}?".format(columns[self.column], condition, str(self.value))


"""### üíÅ‚Äç‚ôÄÔ∏è : Let's implement __Quesetion__ class!"""

Question(1, 3)

Question(0, 'Green')

"""-----
## STEP4. Let's make __partition__ function!
"""


def partition(rows, question):
    """Partitions a dataset
  Arguments:
  rows -- List of row data
  question -- An object of Question class
  """

    true_rows, false_rows = [], []

    for row in rows:
        if question.compare_with_question(row):
            true_rows.append(row)
        else:
            false_rows.append(row)

    return true_rows, false_rows


"""### üíÅ‚Äç‚ôÄÔ∏è : If we partition __'train_data'__ with a question  <font color='red'>"Is color == Redüñç",<font color='black'> what is the true_rows and false_rows? """

true_rows, false_rows = partition(train_data, Question(0, 'Red'))

print("The true_rows\n ===> ", true_rows, "\nThe false_rows\n ===> ", false_rows)

"""----
## STEP5. Let's calculate __"Entropy"__
"""

import numpy as np
from math import log2, e


## JUST RUN IT!
def entropy(labels, base=None):
    """ Computes entropy of label distribution.
  Arguments:
  labels -- Lists of data's label 
  """

    n_labels = len(labels)

    if n_labels <= 1:
        return 0

    counts = class_counts(labels)  # return "dict{class_label : counts}"
    probs = [counts[key] / n_labels for key in counts.keys()]

    n_classes = np.count_nonzero(probs)

    if n_classes <= 1:
        return 0

    ent = 0.

    # Compute entropy
    # base = e if base is None else base
    for i in probs:
        ent -= i * log2(i)

    return ent


"""### üíÅ‚Äç‚ôÄÔ∏è : In ___pure dataset___, how much entropy value did you get?"""

## Pure case
pure = [['Apple'],
        ['Apple']]

# this will return 0
entropy(pure)

"""### üíÅ‚Äç‚ôÄÔ∏è : In ___impure dataset___, how much entropy value did you get?"""

## Impure case
impure = [['Apple'],
          ['Orange']]
entropy(impure)

# Now, we'll look at a dataset with many different labels
impure = [['Apple'],
          ['Orange'],
          ['Grape'],
          ['Grapefruit'],
          ['Blueberry']]

# This will return 2.32
entropy(impure)

"""----
## STEP6. Let's calculate __information gain__
"""


def info_gain(left, right, current_uncertainty):
    """Information Gain.

    IG = The uncertainty of the starting node - the weighted impurity of two child nodes.
    """
    p = float(len(left)) / (len(left) + len(right))

    print("(1) Avg of Impurity = {:.4f} * {:.4f} + {:.4f} * {:.4f}".format(p, entropy(left), (1 - p), entropy(right)))
    print("(2) Current uncertainty = {:.4f}".format(current_uncertainty))

    IG = current_uncertainty - (p * entropy(left) + (1 - p) * entropy(right))

    print("(3) Information gain = {:.4f} - ({:.4f} * {:.4f} + {:.4f} * {:.4f})= {:.4f}\n".
          format(current_uncertainty, p, entropy(left), 1 - p, entropy(right), IG))

    return IG


current_uncertainty = entropy(train_data)
print("\nCurrent uncertainty ===> {:.4f}".format(current_uncertainty))

"""### üíÅ‚Äç‚ôÄÔ∏è : How much information do we gain <font color='green'>by partitioning on 'Green'?"""

print('Question? ', Question(0, 'Green'))

true_rows, false_rows = partition(train_data, Question(0, 'Green'))
print("True_rows ===> {}".format(true_rows))
print("False rows ===> {}\n".format(false_rows))

print("\nThe information gain by partitioning on \"Green\" is {:.4f}".format(
    info_gain(true_rows, false_rows, current_uncertainty)))

"""### üíÅ‚Äç‚ôÄÔ∏è: How much information do we gain <font color='blue'>by partitioning on __diameter >= 3__?"""

print('Question? ', Question(1, 3))

true_rows, false_rows = partition(train_data, Question(1, 3))
print("True_rows ===> {}".format(true_rows))
print("False rows ===> {}\n".format(false_rows))

print("\nThe information gain by partitioning on \"diameter >= 3\" is {:.4f}".format(
    info_gain(true_rows, false_rows, current_uncertainty)))

"""-----
## STEP7. Find **the best split** based on ___Information Gain___
"""


def find_best_split(rows):
    best_gain = 0
    best_question = None

    current_uncertainty = entropy(rows)
    n_features = len(rows[0]) - 1

    for col in range(n_features):

        values = set([row[col] for row in rows])

        for val in values:

            question = Question(col, val)

            true_rows, false_rows = partition(rows, question)

            if len(true_rows) == 0 or len(false_rows) == 0:
                continue

            print('Qustion ====>>> ', question)
            gain = info_gain(true_rows, false_rows, current_uncertainty)

            if gain >= best_gain:
                best_gain, best_question = gain, question

    return best_gain, best_question


best_gain, best_question = find_best_split(train_data)

print("The best question ====>>>>> ", best_question)

"""----
## STEP8. Let's make a __Decision Tree!__üå≤ (JUST RUN IT!)
"""


class Leaf:
    """A Leaf node classifies data.

    This holds a dictionary of class (e.g., "Apple") -> number of times
    it appears in the rows from the training data that reach this leaf.
    """

    def __init__(self, rows):
        ## 'self.predictions' is a dictionary of class counts.
        self.predictions = class_counts(rows)


class Decision_Node:
    """A Decision Node asks a question.

    This holds a reference to the question, and to the two child nodes.
    """

    def __init__(self, question, true_branch, false_branch):
        self.question = question
        self.true_branch = true_branch
        self.false_branch = false_branch


def build_tree(rows):
    """Builds the tree.
  Arguments:
  rows --- List of row data
  """
    gain, question = find_best_split(rows)

    ## If information gain is equal to 0, just return the Leaf object.
    if gain == 0:
        return Leaf(rows)

    true_rows, false_rows = partition(rows, question)

    ## Make additional tree nodes
    true_branch = build_tree(true_rows)

    false_branch = build_tree(false_rows)

    return Decision_Node(question, true_branch, false_branch)


def print_tree(node, spacing=""):
    """Tree printing function."""

    # Base case: we've reached a leaf
    if isinstance(node, Leaf):
        print(spacing + "Predict", node.predictions)
        return

    # Print the question at this node
    print(spacing + str(node.question))

    # Call this function recursively on the true branch
    print(spacing + '--> True:')
    print_tree(node.true_branch, spacing + "  ")

    # Call this function recursively on the false branch
    print(spacing + '--> False:')
    print_tree(node.false_branch, spacing + "  ")


"""### üíÅ‚Äç‚ôÄÔ∏è : Let's build one _Decision Tree_ !"""

my_tree = build_tree(train_data)
print(type(my_tree))

"""### üíÅ‚Äç‚ôÄÔ∏è : Let's print our ___Decision tree___ !"""

print_tree(my_tree)

"""### üíÅ‚Äç‚ôÄÔ∏è : Which results do you get when you classify ___'train_data[0]'___,?"""


def classify(row, node):
    ## If this node is Leaf, return predicted results.
    if isinstance(node, Leaf):
        return node.predictions

    if node.question.compare_with_question(row):
        return classify(row, node.true_branch)
    else:
        return classify(row, node.false_branch)


## Return the each class counts
classify(train_data[0], my_tree)

"""### üíÅ‚Äç‚ôÄÔ∏è : Then, Which class is ___'train_data[0]'___ classified into?"""


def print_leaf(counts):
    """A nicer way to print the predictions at a leaf."""
    total = sum(counts.values()) * 1.0
    probs = {}
    for lbl in counts.keys():
        probs[lbl] = str(int(counts[lbl] / total * 100)) + "%"
    return probs


print_leaf(classify(train_data[1], my_tree))  # Í∞ïÏùòÏûêÎ£åÎûë ÏÇ¨Ïö©Ìïú Ïù∏Îç±Ïä§Í∞Ä Îã¨ÎùºÏÑú ÏàòÏ†ïÌïú Î∂ÄÎ∂Ñ (Í∏∞Ï°¥ = 0)

"""### ==> _If color is yellow and diameter is 3_, this fruit is predicted 100% üçé.

-----
## STEP9. Let's test based on our _**Decision Tree**_
"""

testing_data = [
    ['Green', 3, 'Apple'],
    ['Yellow', 4, 'Apple'],
    ['Red', 2, 'Grape'],
    ['Red', 1, 'Grape'],
    ['Yellow', 3, 'Lemon'],
]

for row in testing_data:
    print("Actual: %s. Predicted: %s" % (row[-1], print_leaf(classify(row, my_tree))))

"""##STEP10. Visualize the decision tree with library"""
from pandas import DataFrame

train_df = DataFrame(train_data)
train_df.columns = ['color', 'diameter', 'label']

"""‚úÖ You don't have to understand below cell. Just run it."""

from sklearn.preprocessing import LabelEncoder

## You don't have to understand it. Just run it.
encoder = LabelEncoder()
train_df['color'] = encoder.fit_transform(train_df['color'])

from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt
import sklearn

decisionTree = DecisionTreeClassifier(random_state=0, criterion='entropy')
decisionTree.fit(train_df.iloc[:, 0:2], train_df.iloc[:, 2])

plt.figure(figsize=(12, 12))
sklearn.tree.plot_tree(decisionTree, filled=True, feature_names=["color", "diameter"], proportion=True)
plt.show()
